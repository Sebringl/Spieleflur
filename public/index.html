<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Spieleflur</title>
  <link rel="icon" href="/icon.png" sizes="1024x1024" type="image/png" />
  <link rel="manifest" href="/manifest.json" />
  <meta name="robots" content="noindex, nofollow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html { font-size: 18px; }
    body { font-family: Arial, sans-serif; text-align: center; padding: 20px; max-width: 760px; margin: auto; transition: background-color 0.2s ease; }
    .dice-container { display: flex; justify-content: center; gap: 14px; margin: 16px 0; }
    .die { font-size: 140px; line-height: 140px; cursor: pointer; padding: 10px; border: 2px solid transparent; border-radius: 10px; user-select: none; }
    .die.inactive { color: #9a9a9a; cursor: default; }
    .held { border-color: green; background-color: #eaffea; }
    button { margin: 8px; font-size: 20px; padding: 12px 18px; }
    input { font-size: 18px; padding: 10px; margin: 6px; width: min(320px, 90%); }
    #result, #throwCount, #playerDisplay { font-size: 18px; margin-top: 10px; transition: color 0.2s ease; }
    #historyTable table { border-collapse: collapse; margin: auto; width: 100%; font-size: 0.9rem; }
    #historyTable th, #historyTable td { border: 1px solid #ccc; padding: 4px 6px; text-align: center; background-color: white; }
    #historyTable th { background-color: #e0e0e0; font-weight: bold; }
    .winner { background-color: #fff9c4; }
    #lobbyCard { border: 1px solid #ddd; border-radius: 12px; padding: 16px; text-align: left; }
    .small { font-size: 14px; opacity: 0.85; }
    .codeBig { font-size: 28px; letter-spacing: 3px; font-weight: 800; text-align: center; margin: 10px 0; }
    .playerList { text-align: left; max-width: 420px; margin: 0 auto; }
    .pill { display:inline-block; padding: 4px 10px; border-radius: 999px; border: 1px solid #ddd; font-size: 13px; margin-left: 8px; }
    .ok { background: #eaffea; }
    .bad { background: #ffe5e5; }
    .neutral { background: #f0f0f0; }
    .toggle-row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; margin: 8px 0; padding: 10px 12px; border: 1px solid #eee; border-radius: 10px; background: #fafafa; }
    .toggle-row input[type="checkbox"] { width: 18px; height: 18px; margin: 0; }
    .toggle-row select { font-size: 16px; padding: 6px 8px; }
    .deckel-inline { display: flex; align-items: center; gap: 6px; margin-left: auto; }
    .code-input-row { display: flex; align-items: center; justify-content: center; gap: 8px; flex-wrap: wrap; }
    .code-input-row input { flex: 0 0 min(320px, 90%); margin: 6px 0; }
    .text-input { width: min(320px, 90%); }
    .icon-btn { border-radius: 10px; margin: 6px 0; }
    .icon-btn span { display: inline-block; transform: rotate(0deg); }
    .refresh-row { margin: 8px 0 12px; }
    .lobby-list { text-align: left; max-width: 420px; margin: 10px auto; }
    .lobby-item { display: flex; align-items: center; justify-content: space-between; gap: 10px; border: 1px solid #eee; border-radius: 10px; padding: 10px; margin: 8px 0; }
    .lobby-item button { margin: 0; }
    .muted { opacity: 0.7; }
    .centered { display: block; margin-left: auto; margin-right: auto; }
    .page-title { margin: 0 0 16px; }
    .page-title-logo { max-width: min(480px, 90%); height: auto; display: inline-block; }
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    footer { margin-top: 24px; font-size: 14px; color: #555; }
    .impressum-link { display: inline-block; margin-top: 20px; font-size: 14px; color: #555; }
    .score-table { border-collapse: collapse; margin: 10px auto; width: 100%; font-size: 0.8rem; }
    .score-table th, .score-table td { border: 1px solid #ccc; padding: 4px 6px; text-align: center; background-color: white; }
    .score-table th { background-color: #e0e0e0; font-weight: bold; }
    .kniffel-select { width: min(360px, 92%); font-size: 16px; padding: 8px; margin: 6px auto; }
    #kniffelView .die { font-size: clamp(56px, 14vw, 130px); line-height: clamp(56px, 14vw, 130px); }
    .card-row { display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; margin: 12px 0; }
    .card { width: 80px; height: 110px; border: 1px solid #ccc; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 28px; background: #fff; cursor: pointer; user-select: none; }
    .card.inactive { cursor: default; opacity: 0.6; }
    .card.selected { border-color: #2e7d32; box-shadow: 0 0 0 2px #a5d6a7; }
    .card.red { color: #c62828; }
    .card-actions { display: flex; justify-content: center; flex-wrap: wrap; gap: 8px; margin: 10px 0; }
  </style>
</head>
<body>
  <h1 id="pageTitle" class="page-title">
    <img id="pageTitleLogo" class="page-title-logo" src="/header_Lobby.png" alt="Spieleflur Lobby" />
    <span id="pageTitleText" class="visually-hidden">Spieleflur (Lobby)</span>
  </h1>

  <div id="lobby">
    <div id="lobbyCard">
      <div class="toggle-row" role="group" aria-label="Spieltyp Einstellungen">
        <label for="gameTypeSelect">Spieltyp</label>
        <select id="gameTypeSelect">
          <option value="schocken">Schocken</option>
          <option value="kniffel">Yahtzee</option>
          <option value="schwimmen">Schwimmen</option>
          <option value="skat">Skat</option>
          <option value="cabo">Kaboh</option>
        </select>
        <label class="deckel-inline" for="deckelToggle">
          <input type="checkbox" id="deckelToggle" />
          <span>Mit Deckeln spielen</span>
        </label>
      </div>

      <hr />
      <div id="rejoinBox" style="display:none;">
        <h3>Wieder beitreten</h3>
        <div class="small">Wir haben ein gespeichertes Room-Login gefunden.</div>
        <button id="btnRejoin">Wieder beitreten</button>
        <button id="btnForget">Vergessen</button>
      </div>

      <hr />
      <h3>Spiel beitreten oder erstellen</h3>
      <div class="small">Name eingeben, Code w√§hlen und loslegen (bei bestehender Lobby best√§tigt der Host).</div>
      <input id="playerName" class="text-input centered" type="text" placeholder="Dein Name" />
      <div class="code-input-row">
        <input id="roomCode" class="text-input" type="text" placeholder="Room-Code (z.B. K7F3Q)" />
        <button id="btnNewCode" class="icon-btn" title="Neuen Code erzeugen" aria-label="Neuen Code erzeugen">
          <span>üîÑ</span>
        </button>
      </div>
      <button id="btnEnter" class="centered">Los!</button>
      <div id="joinStatus" class="small muted"></div>

      <hr />
      <div class="lobby-list" id="activeLobbies">
        <div class="small muted">Aktive Lobbys werden geladen‚Ä¶</div>
      </div>

      <hr />
      <div id="roomView" style="display:none;">
        <h3>Room</h3>
        <div class="codeBig" id="roomCodeBig">------</div>
        <div class="playerList" id="playerList"></div>
        <div class="playerList" id="pendingList"></div>
        <div class="small muted" id="roomSettingsSummary"></div>
        <div id="hostControls" style="display:none; margin-top: 10px;">
          <button id="btnStartGame">Spiel starten</button>
        </div>
        <div id="leaveLobbyWrap" style="display:none; margin-top: 10px;">
          <button id="btnLeaveLobby">Lobby verlassen</button>
        </div>
        <div id="lobbyExpiryNotice" style="display:none; margin-top: 10px; border: 1px solid #f3c97a; border-radius: 10px; padding: 10px; background: #fff7e6;">
          <div class="small" id="lobbyExpiryText"></div>
          <button id="btnKeepLobby" style="margin: 8px 0 0;">Lobby behalten</button>
        </div>
        <div class="small" id="hostStartHint">Nur der Host kann das Spiel starten.</div>
      </div>

      <div id="lobbyError" style="color:red; margin-top: 10px;"></div>
    </div>
  </div>

  <div id="game" style="display:none;">
    <div class="refresh-row">
      <button id="btnReload" class="icon-btn" title="Neu laden" aria-label="Neu laden">üîÑ</button>
    </div>
    <h2 id="playerDisplay">Am Zug: -</h2>
    <div class="small" id="turnHint"></div>

    <div id="schockenView">
      <div class="dice-container">
        <div class="die" id="die0">‚ñ°</div>
        <div class="die" id="die1">‚ñ°</div>
        <div class="die" id="die2">‚ñ°</div>
      </div>

      <button id="rollBtn">W√ºrfeln</button>
      <button id="endTurnBtn">Zug beenden</button>

      <div id="throwCount">Wurf: 0</div>
      <div id="roundDisplay" style="margin-top:10px; font-weight:bold;">Runde: 1</div>
      <div id="result"></div>
    </div>

    <div id="kniffelView" style="display:none;">
      <div class="dice-container">
        <div class="die" id="kniffelDie0">‚ñ°</div>
        <div class="die" id="kniffelDie1">‚ñ°</div>
        <div class="die" id="kniffelDie2">‚ñ°</div>
        <div class="die" id="kniffelDie3">‚ñ°</div>
        <div class="die" id="kniffelDie4">‚ñ°</div>
      </div>

      <button id="kniffelRollBtn">W√ºrfeln</button>
      <button id="kniffelEndTurnBtn">Kategorie sichern</button>

      <div id="kniffelThrowCount">Wurf: 0</div>
      <select id="kniffelCategorySelect" class="kniffel-select"></select>
      <div id="kniffelResult"></div>
      <div id="kniffelScoreTable" style="margin-top: 14px;"></div>
    </div>

    <div id="schwimmenView" style="display:none;">
      <div class="small muted">Tischkarten</div>
      <div class="card-row" id="schwimmenTable"></div>

      <div class="small muted">Deine Karten</div>
      <div class="card-row" id="schwimmenHand"></div>

      <div class="card-actions">
        <button id="schwimmenSwapBtn">1 Karte tauschen</button>
        <button id="schwimmenSwapAllBtn">Alle tauschen</button>
        <button id="schwimmenPassBtn">Schieben</button>
        <button id="schwimmenKnockBtn">Klopfen</button>
        <button id="schwimmenNextRoundBtn" style="display:none;">Neue Runde starten</button>
      </div>

      <div id="schwimmenResult"></div>
      <div id="schwimmenScores" style="margin-top: 14px;"></div>
    </div>

    <div id="skatView" style="display:none;">
      <div class="small muted">Skat (3 Spieler)</div>
      <div id="skatPlayers" class="playerList"></div>
      <div class="small muted">Stich</div>
      <div class="card-row" id="skatTrick"></div>
      <div class="small muted">Deine Karten</div>
      <div class="card-row" id="skatHand"></div>
      <div id="skatResult" style="margin-top: 10px;"></div>
    </div>

    <div id="caboView" style="display:none;">
      <div class="small muted">Kaboh (Punkte√ºbersicht)</div>
      <div id="caboRound" style="margin-top: 6px; font-weight: bold;"></div>
      <div id="caboScores" style="margin-top: 14px;"></div>
      <div class="card-actions">
        <label for="caboScoreInput" class="small">Rundenpunkte</label>
        <input id="caboScoreInput" type="number" step="1" value="0" style="width: 120px;" />
        <button id="caboEndTurnBtn">Zug beenden</button>
      </div>
      <div id="caboResult" style="margin-top: 10px;"></div>
    </div>

    <div id="historyTable" style="margin-top: 14px;"></div>

    <div id="backToLobbyWrap" style="margin-top: 14px;">
      <button id="btnBackToLobby">Zur√ºck zur Lobby</button>
      <div class="small">Beendet das Spiel und l√∂scht den Fortschritt.</div>
    </div>
  </div>

  <footer>
    <details style="margin: 18px 0; text-align: left;">
      <summary>Kaboh-Regeln anzeigen</summary>
      <div class="small" style="margin-top: 10px;">
        <p><strong>Ziel:</strong> Am Ende die wenigsten Punkte in deiner verdeckten Auslage haben. Du kennst deine Karten nur teilweise.</p>
        <h4>Vorbereitung</h4>
        <ol>
          <li>Jeder bekommt 4 Karten und legt sie verdeckt nebeneinander vor sich.</li>
          <li>Rest als Nachziehstapel verdeckt in die Mitte.</li>
          <li>1 Karte aufdecken neben den Nachziehstapel = Start vom Ablagestapel.</li>
          <li>Jeder darf einmalig 2 seiner 4 Karten ansehen. Danach Karten nicht mehr anschauen und nicht mehr umsortieren (au√üer per Aktionskarte).</li>
          <li>Startspieler bestimmen, dann im Uhrzeigersinn.</li>
        </ol>
        <h4>Zugablauf (du w√§hlst 1 von 3 Optionen)</h4>
        <p><strong>Option 1:</strong> Nimm die oberste Karte vom Ablagestapel und tausche sie gegen 1 Karte aus deiner Auslage (oder gegen ein Duett/Triplett/Quartett ‚Äì siehe unten).</p>
        <p><strong>Option 2:</strong> Ziehe die oberste Karte vom Nachziehstapel, schau sie an und dann:</p>
        <ul>
          <li><strong>(2a)</strong> direkt auf den Ablagestapel werfen oder</li>
          <li><strong>(2b)</strong> mit 1 Karte aus deiner Auslage tauschen, die ersetzte Karte kommt auf den Ablagestapel oder</li>
          <li><strong>(2c)</strong> wenn es eine Aktionskarte ist: Aktion ausf√ºhren (nur dann!) und die Karte danach auf den Ablagestapel werfen.</li>
        </ul>
        <p><strong>Option 3:</strong> Stattdessen ‚ÄûKaboh‚Äú ansagen (siehe Kaboh-Regel).</p>
        <h4>Duett / Triplett / Quartett (gleiche Werte ‚Äûwegtauchen‚Äú)</h4>
        <p>Du darfst 2/3/4 Karten gleichen Wertes aus deiner Auslage gegen genau 1 Karte vom Nachzieh- oder Ablagestapel tauschen (macht deine Auslage kleiner).</p>
        <ul>
          <li>Du zeigst die Karten offen allen, legst sie auf den Ablagestapel.</li>
          <li>Wenn auch nur eine Karte nicht passt: alle vermeintlichen Tauschkarten gehen zur√ºck auf ihre Pl√§tze, die gezogene Karte geht auf den Ablagestapel ‚Üí Zug verloren.</li>
        </ul>
        <h4>Aktionskarten</h4>
        <ul>
          <li><strong>Peek:</strong> 1 eigene Karte ansehen.</li>
          <li><strong>Spy:</strong> 1 Karte bei einem Mitspieler ansehen.</li>
          <li><strong>Swap:</strong> 1 eigene Karte mit 1 Karte eines Mitspielers tauschen, ohne sie anzusehen.</li>
        </ul>
        <p><strong>Wichtig:</strong></p>
        <ul>
          <li>Aktionskarten vom Nachziehstapel: entweder sofort ausf√ºhren (nur direkt nach dem Ziehen!) und abwerfen oder wie Punktekarten behandeln (einbauen/abwerfen ohne Aktion).</li>
          <li>Karten vom Ablagestapel oder Karten, die schon ausliegen, z√§hlen nur als Punktekarten, keine Aktionen.</li>
        </ul>
        <h4>Kaboh ansagen</h4>
        <p>Wenn du glaubst, du hast die wenigsten Punkte, kannst du deinen Zug nutzen, um ‚ÄûKaboh‚Äú zu sagen.</p>
        <ul>
          <li>Dann ziehst/legst du in diesem Zug nichts mehr.</li>
          <li>Danach haben alle anderen genau noch 1 Zug, dann endet die Runde.</li>
        </ul>
        <h4>Wertung</h4>
        <ul>
          <li>Alle decken auf und addieren ihre Kartenpunkte.</li>
          <li>Niedrigste Summe gewinnt: 0 Punkte. Alle anderen notieren ihre Summe als Minuspunkte.</li>
          <li>Wenn der Kaboh-Ansager nicht die niedrigste Summe hat: +5 Strafpunkte (oder mehr nach Vereinbarung).</li>
          <li>Gleichstand: Kaboh-Ansager gewinnt. Wenn mehrere ohne Kaboh gleich niedrig: alle diese gewinnen und schreiben 0.</li>
        </ul>
        <h4>Kamikaze-Sonderregel</h4>
        <p>Wenn du am Ende 12+12+13+13 hast, gewinnst du sofort (0 Punkte) und alle anderen bekommen 50 Minuspunkte.</p>
        <h4>Partien √ºber mehrere Runden (optional)</h4>
        <ul>
          <li>Minuspunkte √ºber mehrere Partien addieren.</li>
          <li>Bei &gt;100 Minuspunkten endet‚Äôs, niedrigste Gesamtpunkte gewinnen.</li>
          <li>Exakt 100 ‚Üí wird auf 50 reduziert.</li>
        </ul>
      </div>
    </details>
    <a class="impressum-link" href="/impressum.html" target="_blank" rel="noopener noreferrer">Impressum</a>
  </footer>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();

    const diceSymbols = ['‚öÄ','‚öÅ','‚öÇ','‚öÉ','‚öÑ','‚öÖ'];
    const playerTextColors = ['#e6194b','#4363d8','#f58231','#911eb4','#008080','#f032e6','#bcf60c','#0082c8'];
    const playerBgColors   = ['#ffe5e5','#e5e5ff','#fff5e5','#f5e5ff','#e5f5ff','#ffe5f5','#f5ffe5','#e5ffff'];
    const kniffelCategories = [
      { key: "ones", label: "Einer" },
      { key: "twos", label: "Zweier" },
      { key: "threes", label: "Dreier" },
      { key: "fours", label: "Vierer" },
      { key: "fives", label: "F√ºnfer" },
      { key: "sixes", label: "Sechser" },
      { key: "threeKind", label: "Dreierpasch" },
      { key: "fourKind", label: "Viererpasch" },
      { key: "fullHouse", label: "Full House" },
      { key: "smallStraight", label: "Kleine Stra√üe" },
      { key: "largeStraight", label: "Gro√üe Stra√üe" },
      { key: "yahtzee", label: "Yahtzee" },
      { key: "chance", label: "Chance" }
    ];
    const gameTypeLabels = {
      schocken: "Schocken",
      kniffel: "Yahtzee",
      schwimmen: "Schwimmen",
      skat: "Skat",
      cabo: "Kaboh"
    };
    const gameTypeRequirements = {
      schocken: { min: 2 },
      kniffel: { min: 2 },
      schwimmen: { min: 2 },
      skat: { exact: 3 },
      cabo: { min: 2 }
    };

    let myToken    = localStorage.getItem("schocken_token") || null;
    let myRoomCode = localStorage.getItem("schocken_code") || null;
    let mySeat     = Number(localStorage.getItem("schocken_seat") || "-1");
    let myName     = localStorage.getItem("schocken_name") || "";
    let isHost     = false;
    let wasMyTurn  = false;
    let joinPending = null;

    let room = null;
    let state = null;
    let selectedHandIndex = null;
    let selectedTableIndex = null;

    const headerImages = {
      lobby: "/header_Lobby.png",
      schocken: "/header_schocken.png",
      schwimmen: "/header_schwimmen.png",
      kniffel: "/header_yahtzee.png",
      skat: "/header_Lobby.png",
      cabo: "/header_Lobby.png"
    };

    function updateHeader(view) {
      const logo = document.getElementById("pageTitleLogo");
      const titleText = document.getElementById("pageTitleText");
      if (!logo || !titleText) return;
      const typeKey = view === "lobby" ? getSelectedGameType() : (room?.settings?.gameType || "schocken");
      const gameTitle = gameTypeLabels[typeKey] || "Schocken";
      const headerSrc = view === "lobby" ? headerImages.lobby : (headerImages[typeKey] || headerImages.schocken);
      logo.src = headerSrc;
      logo.alt = view === "lobby" ? "Spieleflur Lobby" : `${gameTitle} Header`;
      titleText.textContent = (view === "game" && room && room.code) ? `${gameTitle} (${room.code})` : `${gameTitle} (Lobby)`;
    }

    function setView(view) {
      document.getElementById("lobby").style.display = (view === "lobby") ? "block" : "none";
      document.getElementById("game").style.display  = (view === "game") ? "block" : "none";
      updateHeader(view);
    }
    function showLobbyError(msg) {
      document.getElementById("lobbyError").textContent = msg || "";
    }
    function showLobbyExpiryNotice(msg) {
      const notice = document.getElementById("lobbyExpiryNotice");
      const text = document.getElementById("lobbyExpiryText");
      if (!notice || !text) return;
      if (!msg) {
        notice.style.display = "none";
        text.textContent = "";
        return;
      }
      text.textContent = msg;
      notice.style.display = "block";
    }
    function showJoinStatus(msg) {
      document.getElementById("joinStatus").textContent = msg || "";
    }
    function canEnterRoom(requestedCode) {
      if (myRoomCode && myToken) {
        const normalized = String(requestedCode || "").trim().toUpperCase();
        if (!normalized || normalized !== myRoomCode) {
          showLobbyError("Du bist bereits in einer Lobby. Bitte wieder beitreten.");
          return false;
        }
      }
      return true;
    }
    function showGameMessage(msg, isError=false) {
      const el = getGameResultElement();
      if (!el) return;
      el.textContent = msg || "";
      el.style.color = isError ? "red" : "black";
    }
    function makeCode(len = 5) {
      const alphabet = "23456789ABCDEFGHJKMNPQRSTUVWXYZ";
      let s = "";
      for (let i = 0; i < len; i++) s += alphabet[Math.floor(Math.random() * alphabet.length)];
      return s;
    }
    function setSuggestedCode() {
      document.getElementById("roomCode").value = makeCode();
    }
    function getPlayerName() {
      return document.getElementById("playerName").value.trim();
    }
    function storePlayerName(name) {
      myName = name;
      localStorage.setItem("schocken_name", name);
    }
    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, m => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[m]));
    }
    function getGameTypeLabel(value) {
      return gameTypeLabels[value] || "Schocken";
    }
    function getSelectedGameType() {
      const select = document.getElementById("gameTypeSelect");
      return select ? select.value : "schocken";
    }
    function getGameTypeRequirement(value) {
      return gameTypeRequirements[value] || { min: 2 };
    }

    function isMyTurn() {
      return state && mySeat >= 0 && state.currentPlayer === mySeat;
    }

    function isKniffelGame() {
      return room && room.settings && room.settings.gameType === "kniffel";
    }

    function isSchwimmenGame() {
      return room && room.settings && room.settings.gameType === "schwimmen";
    }

    function isSkatGame() {
      return room && room.settings && room.settings.gameType === "skat";
    }

    function isCaboGame() {
      return room && room.settings && room.settings.gameType === "cabo";
    }

    function getGameResultElement() {
      if (isKniffelGame()) return document.getElementById("kniffelResult");
      if (isSchwimmenGame()) return document.getElementById("schwimmenResult");
      if (isSkatGame()) return document.getElementById("skatResult");
      if (isCaboGame()) return document.getElementById("caboResult");
      return document.getElementById("result");
    }

    async function notifyMyTurn(playerName) {
      if (!("Notification" in window)) return;
      if (Notification.permission === "denied") return;

      if (Notification.permission === "default") {
        try {
          const permission = await Notification.requestPermission();
          if (permission !== "granted") return;
        } catch (err) {
          return;
        }
      }

      const title = "Du bist am Zug";
      const body = playerName ? `Am Zug: ${playerName}` : "Jetzt bist du dran!";

      if ("serviceWorker" in navigator) {
        try {
          const reg = await navigator.serviceWorker.ready;
          await reg.showNotification(title, {
            body,
            icon: "/icon.png",
            badge: "/icon.png"
          });
          return;
        } catch (err) {
          // fall back to window notification
        }
      }

      try {
        new Notification(title, { body });
      } catch (err) {
        // ignore
      }
    }

    async function notifyJoinRequest(playerName, code, requestId) {
      if (!("Notification" in window)) return;
      if (Notification.permission === "denied") return;

      if (Notification.permission === "default") {
        try {
          const permission = await Notification.requestPermission();
          if (permission !== "granted") return;
        } catch (err) {
          return;
        }
      }

      const title = "Beitrittsanfrage";
      const body = `${playerName} m√∂chte Lobby ${code} beitreten.`;

      if ("serviceWorker" in navigator) {
        try {
          const reg = await navigator.serviceWorker.ready;
          await reg.showNotification(title, {
            body,
            icon: "/icon.png",
            badge: "/icon.png",
            data: { code, requestId },
            actions: [
              { action: "approve", title: "Annehmen" },
              { action: "deny", title: "Ablehnen" }
            ]
          });
          return;
        } catch (err) {
          // fall back to window notification
        }
      }

      try {
        new Notification(title, { body });
      } catch (err) {
        // ignore
      }
    }

    function renderRoomView() {
      if (!room) return;
      document.getElementById("roomView").style.display = "block";
      document.getElementById("roomCodeBig").textContent = room.code;

      const list = room.players || [];
      let html = "<h4>Spieler</h4><ul>";
      list.forEach((p, index) => {
        const connected = p.connected ? `<span class="pill ok">online</span>` : `<span class="pill bad">offline</span>`;
        const hostBadge = index === room.hostSeat ? `<span class="pill neutral">Host</span>` : "";
        html += `<li>${escapeHtml(p.name)} ${connected} ${hostBadge}</li>`;
      });
      html += "</ul>";
      document.getElementById("playerList").innerHTML = html;

      document.getElementById("hostControls").style.display =
        isHost && room.status === "lobby" ? "block" : "none";
      document.getElementById("leaveLobbyWrap").style.display =
        room.status === "lobby" ? "block" : "none";
      const hint = document.getElementById("hostStartHint");
      if (hint) {
        hint.textContent = isHost ? "Nur du kannst das Spiel starten." : "Nur der Host kann das Spiel starten.";
      }
      renderPendingList([]);
      updateDeckelToggleState();
      updateGameTypeSelectState();
      updateLobbyVisibility();
      updateStartButtonState();
      const settingsSummary = document.getElementById("roomSettingsSummary");
      if (settingsSummary && room?.settings) {
        const typeLabel = getGameTypeLabel(room.settings.gameType);
        if (room.settings.gameType === "schocken") {
          const deckelLabel = room.settings.useDeckel ? "mit Deckeln" : "ohne Deckel";
          settingsSummary.textContent = `Einstellungen: ${typeLabel} ¬∑ ${deckelLabel}`;
        } else {
          settingsSummary.textContent = `Einstellungen: ${typeLabel}`;
        }
      }
      if (!room || room.status !== "lobby") {
        showLobbyExpiryNotice("");
      }
    }

    function renderPendingList(requests) {
      const container = document.getElementById("pendingList");
      if (!isHost) {
        container.innerHTML = "";
        container.style.display = "none";
        return;
      }
      if (!requests || requests.length === 0) {
        container.innerHTML = "";
        container.style.display = "none";
        return;
      }
      container.style.display = "block";
      let html = "<h4>Beitrittsanfragen</h4><ul>";
      requests.forEach(req => {
        const safeName = escapeHtml(req.name);
        html += `<li>${safeName}
          <button class="icon-btn" data-approve="${req.id}" title="Annehmen">‚úÖ</button>
          <button class="icon-btn" data-deny="${req.id}" title="Ablehnen">‚ùå</button>
        </li>`;
      });
      html += "</ul>";
      container.innerHTML = html;

      container.querySelectorAll("button[data-approve]").forEach(btn => {
        btn.onclick = () => {
          if (!room || !myToken) return;
          socket.emit("approve_join", { code: room.code, token: myToken, requestId: btn.dataset.approve, accept: true });
        };
      });
      container.querySelectorAll("button[data-deny]").forEach(btn => {
        btn.onclick = () => {
          if (!room || !myToken) return;
          socket.emit("approve_join", { code: room.code, token: myToken, requestId: btn.dataset.deny, accept: false });
        };
      });
    }

    function renderLobbyList(lobbies) {
      const container = document.getElementById("activeLobbies");
      if (room && room.status === "lobby") {
        container.style.display = "none";
        container.innerHTML = "";
        return;
      }
      container.style.display = "block";
      if (!lobbies || lobbies.length === 0) {
        container.innerHTML = "<div class='small muted'>Keine aktiven Lobbys gefunden.</div>";
        return;
      }
      let html = "<h4>Aktive Lobbys</h4>";
      lobbies.forEach(lobby => {
        const host = escapeHtml(lobby.hostName || "Host");
        const gameLabel = gameTypeLabels[lobby.gameType] || "Schocken";
        html += `<div class="lobby-item">
          <div>
            <div><strong>${lobby.code}</strong> ¬∑ ${host}</div>
            <div class="small muted">${lobby.playerCount} Spieler ¬∑ ${gameLabel}${lobby.gameType === "schocken" ? (lobby.useDeckel ? " ¬∑ mit Deckeln" : " ¬∑ ohne Deckel") : ""}</div>
          </div>
          <button data-join="${lobby.code}">Beitreten</button>
        </div>`;
      });
      container.innerHTML = html;
      container.querySelectorAll("button[data-join]").forEach(btn => {
        btn.onclick = () => {
          const name = getPlayerName();
          const code = btn.dataset.join;
          if (!name) return showLobbyError("Bitte Name eingeben.");
          if (!canEnterRoom(code)) return;
          showLobbyError("");
          showJoinStatus(`Beitritt f√ºr ${code} angefragt‚Ä¶`);
          joinPending = { code };
          document.getElementById("roomCode").value = code;
          socket.emit("enter_room", {
            name,
            requestedCode: code,
            useDeckel: document.getElementById("deckelToggle").checked,
            gameType: getSelectedGameType()
          });
        };
      });
    }

    function getRoundBestPlayerIndex(round) {
      const entries = round
        .map((entry, i) => ({ ...entry, index: i }))
        .filter(e => e && e.label && typeof e.tier !== "undefined");
      if (!entries.length) return null;
      entries.sort((a, b) => {
        if (a.tier !== b.tier) return b.tier - a.tier;
        if (a.subvalue !== b.subvalue) return b.subvalue - a.subvalue;
        if (a.throws !== b.throws) return a.throws - b.throws;
        return a.index - b.index;
      });
      return entries[0].index;
    }

    function updateHistoryTable() {
      const historyContainer = document.getElementById("historyTable");
      if (!state || !state.history || !state.history.length) {
        historyContainer.innerHTML = "";
        historyContainer.style.display = "none";
        return;
      }
      historyContainer.style.display = "block";

      const players = state.players;
      const history = state.history;
      let html = "<h3>Spielverlauf</h3><table>";
      if (state.gameType === "schwimmen") {
        html += "<tr><th rowspan='2'>Runde</th>";
        players.forEach((name, i) => {
          const isOut = state.eliminated?.[i];
          const displayName = isOut ? `${escapeHtml(name)} (aus)` : escapeHtml(name);
          html += `<th colspan="2" style="color:${playerTextColors[i % playerTextColors.length]};">${displayName}</th>`;
        });
        html += "</tr>";

        html += "<tr>";
        players.forEach(() => {
          html += "<th>üÇ†</th><th>‚ù§Ô∏è</th>";
        });
        html += "</tr>";

        for (let i = history.length - 1; i >= 0; i--) {
          const r = history[i];
          html += `<tr><td>${i + 1}</td>`;
          players.forEach((_, p) => {
            const entry = r[p];
            if (!entry) {
              html += "<td>-</td><td>-</td>";
              return;
            }
            const scoreLabel = entry.score === null || typeof entry.score === "undefined" ? "-" : entry.score;
            let livesLabel = entry.lives ?? "-";
            if (entry.eliminated) {
              livesLabel = "aus";
            } else if (entry.swimming) {
              livesLabel = "üèä";
            }
            html += `<td>${scoreLabel}</td><td>${livesLabel}</td>`;
          });
          html += "</tr>";
        }
      } else if (state.gameType === "cabo") {
        html += "<tr><th>Runde</th>";
        players.forEach((name, i) => {
          html += `<th style="color:${playerTextColors[i % playerTextColors.length]};">${escapeHtml(name)}</th>`;
        });
        html += "</tr>";

        for (let i = history.length - 1; i >= 0; i--) {
          const r = history[i];
          html += `<tr><td>${i + 1}</td>`;
          players.forEach((_, p) => {
            const entry = r?.[p];
            const scoreLabel = entry === null || typeof entry === "undefined" ? "-" : entry;
            html += `<td>${scoreLabel}</td>`;
          });
          html += "</tr>";
        }
      } else {
        const useDeckel = !!state.useDeckel;
        const wins = state.wins || [];
        const deckelCount = state.deckelCount || [];

        html += "<tr><th rowspan='2'>Runde</th>";
        players.forEach((name, i) => {
          let displayName = useDeckel ? `${escapeHtml(name)} (${deckelCount[i] || 0})`
                                      : ((wins[i] > 0) ? `${escapeHtml(name)} (${wins[i]} üëë)` : escapeHtml(name));
          html += `<th colspan="2" style="color:${playerTextColors[i % playerTextColors.length]};">${displayName}</th>`;
        });
        html += "</tr>";

        html += "<tr>";
        players.forEach(() => {
          html += `<th>üé≤</th><th>${useDeckel ? "Deckel" : "üîÅ"}</th>`;
        });
        html += "</tr>";

        for (let i = history.length - 1; i >= 0; i--) {
          const r = history[i];
          const winnerIndex = getRoundBestPlayerIndex(r);

          html += `<tr><td>${i + 1}</td>`;
          players.forEach((_, p) => {
            const entry = r[p];
            const isWinner = p === winnerIndex && entry;
            const cls = isWinner ? "winner" : "";
            if (entry) {
              html += `<td class="${cls}">${escapeHtml(entry.label)}</td>`;
              html += `<td class="${cls}">${useDeckel ? (deckelCount[p] || 0) : entry.throws}</td>`;
            } else {
              html += `<td>-</td><td>-</td>`;
            }
          });
          html += "</tr>";
        }
      }

      html += "</table>";
      historyContainer.innerHTML = html;
    }

    function renderKniffelScoreTable() {
      if (!state || !state.scorecard) {
        document.getElementById("kniffelScoreTable").innerHTML = "";
        return;
      }
      let html = "<h3>Scorecard</h3><table class='score-table'>";
      html += "<tr><th>Kategorie</th>";
      state.players.forEach((name, i) => {
        html += `<th style="color:${playerTextColors[i % playerTextColors.length]};">${escapeHtml(name)}</th>`;
      });
      html += "</tr>";

      kniffelCategories.forEach(cat => {
        html += `<tr><td>${cat.label}</td>`;
        state.players.forEach((_, pIdx) => {
          const val = state.scorecard[pIdx]?.[cat.key];
          html += `<td>${val === null || typeof val === "undefined" ? "-" : val}</td>`;
        });
        html += "</tr>";
      });

      html += "<tr><th>Summe</th>";
      state.players.forEach((_, pIdx) => {
        html += `<th>${state.totals?.[pIdx] || 0}</th>`;
      });
      html += "</tr></table>";
      document.getElementById("kniffelScoreTable").innerHTML = html;
    }

    function renderKniffelCategorySelect(myTurn) {
      const select = document.getElementById("kniffelCategorySelect");
      if (!select || !state || !state.scorecard) return;
      const card = state.scorecard[mySeat] || {};
      select.innerHTML = "<option value=''>Kategorie w√§hlen‚Ä¶</option>";
      kniffelCategories.forEach(cat => {
        const used = card && card[cat.key] !== null && typeof card[cat.key] !== "undefined";
        const opt = document.createElement("option");
        opt.value = cat.key;
        opt.textContent = used ? `${cat.label} (belegt)` : cat.label;
        opt.disabled = used;
        select.appendChild(opt);
      });
      select.disabled = !myTurn;
    }

    function updateKniffelEndButton() {
      const endBtn = document.getElementById("kniffelEndTurnBtn");
      const select = document.getElementById("kniffelCategorySelect");
      if (!endBtn || !select || !state) return;
      const myTurn = isMyTurn();
      endBtn.disabled = !myTurn || state.throwCount === 0 || state.dice.includes(null) || !select.value || state.finished;
    }

    function renderKniffelGame() {
      if (!state) return;
      document.getElementById("schockenView").style.display = "none";
      document.getElementById("kniffelView").style.display = "block";
      document.getElementById("schwimmenView").style.display = "none";
      document.getElementById("skatView").style.display = "none";
      document.getElementById("caboView").style.display = "none";
      document.getElementById("historyTable").style.display = "none";
      document.getElementById("historyTable").innerHTML = "";

      const currentName = state.players[state.currentPlayer] || "-";
      document.getElementById("playerDisplay").textContent = `Am Zug: ${currentName}`;
      document.getElementById("kniffelThrowCount").textContent = `Wurf: ${state.throwCount}`;

      const colorIdx = state.currentPlayer % playerTextColors.length;
      document.getElementById("playerDisplay").style.color = playerTextColors[colorIdx];
      document.body.style.backgroundColor = playerBgColors[colorIdx];

      const myTurn = isMyTurn();
      for (let i = 0; i < 5; i++) {
        const el = document.getElementById(`kniffelDie${i}`);
        const val = state.dice[i];
        el.textContent = val ? diceSymbols[val - 1] : "‚ñ°";
        el.className = "die" + (state.held[i] ? " held" : "") + (!myTurn ? " inactive" : "");
        el.onclick = () => {
          if (!myTurn) return;
          socket.emit("action_toggle", { code: room.code, index: i });
        };
      }

      const remaining = state.maxThrowsThisRound - state.throwCount;
      const allHeld = state.held.every(h => h);
      const rollBtn = document.getElementById("kniffelRollBtn");
      rollBtn.textContent = allHeld ? "Alle W√ºrfel gehalten" : `W√ºrfeln (${remaining})`;
      rollBtn.disabled = !myTurn || allHeld || remaining <= 0 || state.finished;

      renderKniffelCategorySelect(myTurn);
      updateKniffelEndButton();

      document.getElementById("turnHint").textContent =
        myTurn ? "Du bist am Zug!" : "Du bist gerade nicht am Zug (Zuschauer-Modus).";
      document.getElementById("backToLobbyWrap").style.display = isHost ? "block" : "none";
      updateDeckelToggleState();
      updateLobbyVisibility();

      const myTurnNow = myTurn;
      if (myTurnNow && !wasMyTurn) {
        notifyMyTurn(currentName);
      }
      wasMyTurn = myTurnNow;

      const msg = state.message || "";
      document.getElementById("kniffelResult").textContent = msg;

      renderKniffelScoreTable();
    }

    function formatSchwimmenCard(card) {
      if (!card) return "üÇ†";
      return `${card.rank}${card.suit}`;
    }

    function formatSkatCard(card) {
      if (!card) return "üÇ†";
      return `${card.rank}${card.suit}`;
    }

    function isRedSuit(card) {
      return card && (card.suit === "‚ô•" || card.suit === "‚ô¶");
    }

    function renderSkatRow(container, cards, { selectable, onSelect, hideCards }) {
      if (!container) return;
      container.innerHTML = "";
      cards.forEach((card, index) => {
        const el = document.createElement("div");
        el.className = "card";
        if (hideCards) {
          el.textContent = "üÇ†";
          el.classList.add("inactive");
        } else {
          el.textContent = formatSkatCard(card);
          if (isRedSuit(card)) el.classList.add("red");
        }
        if (!selectable) el.classList.add("inactive");
        if (selectable && !hideCards) {
          el.onclick = () => onSelect(index);
        }
        container.appendChild(el);
      });
    }

    function renderSchwimmenRow(container, cards, { selectable, selectedIndex, onSelect, hideCards }) {
      if (!container) return;
      container.innerHTML = "";
      cards.forEach((card, index) => {
        const el = document.createElement("div");
        el.className = "card";
        if (hideCards) {
          el.textContent = "üÇ†";
          el.classList.add("inactive");
        } else {
          el.textContent = formatSchwimmenCard(card);
          if (isRedSuit(card)) el.classList.add("red");
        }
        if (selectedIndex === index) el.classList.add("selected");
        if (!selectable) el.classList.add("inactive");
        if (selectable && !hideCards) {
          el.onclick = () => onSelect(index);
        }
        container.appendChild(el);
      });
    }

    function renderSchwimmenScores() {
      const container = document.getElementById("schwimmenScores");
      if (!container) return;
      if (!state || !state.scores || state.scores.length === 0) {
        container.innerHTML = "";
        return;
      }
      let html = "<table class='score-table'><thead><tr><th>Spieler</th><th>Punkte</th></tr></thead><tbody>";
      state.players.forEach((name, index) => {
        const score = state.scores[index];
        html += `<tr><td>${escapeHtml(name)}</td><td>${score ?? "-"}</td></tr>`;
      });
      html += "</tbody></table>";
      container.innerHTML = html;
    }

    function renderSchwimmenGame() {
      if (!state) return;
      document.getElementById("kniffelView").style.display = "none";
      document.getElementById("schockenView").style.display = "none";
      document.getElementById("schwimmenView").style.display = "block";
      document.getElementById("skatView").style.display = "none";
      document.getElementById("caboView").style.display = "none";

      const currentName = state.players[state.currentPlayer] || "-";
      document.getElementById("playerDisplay").textContent = `Am Zug: ${currentName}`;

      const colorIdx = state.currentPlayer % playerTextColors.length;
      document.getElementById("playerDisplay").style.color = playerTextColors[colorIdx];
      document.body.style.backgroundColor = playerBgColors[colorIdx];

      const myTurn = isMyTurn();
      if (!myTurn || state.finished || state.roundPending) {
        selectedHandIndex = null;
        selectedTableIndex = null;
      }
      const myHand = mySeat >= 0 ? (state.hands?.[mySeat] || []) : [null, null, null];
      const tableCards = state.tableCards || [];

      renderSchwimmenRow(
        document.getElementById("schwimmenTable"),
        tableCards,
        {
          selectable: myTurn && !state.finished,
          selectedIndex: selectedTableIndex,
          onSelect: (index) => {
            if (!myTurn) return;
            selectedTableIndex = selectedTableIndex === index ? null : index;
            renderSchwimmenGame();
          },
          hideCards: false
        }
      );
      renderSchwimmenRow(
        document.getElementById("schwimmenHand"),
        myHand,
        {
          selectable: myTurn && !state.finished,
          selectedIndex: selectedHandIndex,
          onSelect: (index) => {
            if (!myTurn) return;
            selectedHandIndex = selectedHandIndex === index ? null : index;
            renderSchwimmenGame();
          },
          hideCards: mySeat < 0 && !state.finished
        }
      );

      const swapBtn = document.getElementById("schwimmenSwapBtn");
      const swapAllBtn = document.getElementById("schwimmenSwapAllBtn");
      const passBtn = document.getElementById("schwimmenPassBtn");
      const knockBtn = document.getElementById("schwimmenKnockBtn");
      const nextRoundBtn = document.getElementById("schwimmenNextRoundBtn");

      const canActNow = myTurn && !state.finished && !state.roundPending;
      if (swapBtn) swapBtn.disabled = !canActNow || selectedHandIndex === null || selectedTableIndex === null;
      if (swapAllBtn) swapAllBtn.disabled = !canActNow;
      if (passBtn) passBtn.disabled = !canActNow;
      if (knockBtn) knockBtn.disabled = !canActNow || state.knockedBy !== null;
      if (nextRoundBtn) {
        const showNextRound = !!state.roundPending && !state.finished;
        const canStartNext = showNextRound && (mySeat === state.nextStartingSeat || isHost);
        nextRoundBtn.style.display = showNextRound ? "inline-block" : "none";
        nextRoundBtn.disabled = !canStartNext;
      }

      document.getElementById("turnHint").textContent =
        myTurn ? "Du bist am Zug!" : "Du bist gerade nicht am Zug (Zuschauer-Modus).";
      document.getElementById("backToLobbyWrap").style.display = isHost ? "block" : "none";
      updateDeckelToggleState();
      updateLobbyVisibility();

      const myTurnNow = myTurn;
      if (myTurnNow && !wasMyTurn) {
        notifyMyTurn(currentName);
      }
      wasMyTurn = myTurnNow;

      const knockInfo = state.knockedBy !== null && !state.finished
        ? `Geklopft von ${state.players[state.knockedBy]} ¬∑ noch ${state.lastTurnsRemaining} Z√ºge`
        : "";
      const nextRoundInfo = state.roundPending && !state.finished
        ? `Neue Runde wartet auf ${state.players[state.nextStartingSeat] ?? "?"}`
        : "";
      const info = [state.message, knockInfo, nextRoundInfo].filter(Boolean).join(" ¬∑ ");
      document.getElementById("schwimmenResult").textContent = info;

      renderSchwimmenScores();
      updateHistoryTable();
    }

    function renderSkatGame() {
      if (!state) return;
      document.getElementById("kniffelView").style.display = "none";
      document.getElementById("schockenView").style.display = "none";
      document.getElementById("schwimmenView").style.display = "none";
      document.getElementById("skatView").style.display = "block";
      document.getElementById("caboView").style.display = "none";
      document.getElementById("historyTable").style.display = "none";
      document.getElementById("historyTable").innerHTML = "";

      const playerCount = state.players?.length || 0;
      const currentName = state.players?.[state.currentPlayer] || "-";
      document.getElementById("playerDisplay").textContent = `Am Zug: ${currentName}`;
      document.getElementById("playerDisplay").style.color = "";
      document.body.style.backgroundColor = "";

      document.getElementById("turnHint").textContent =
        isMyTurn() ? "Du bist am Zug!" : "Du bist gerade nicht am Zug (Zuschauer-Modus).";
      document.getElementById("backToLobbyWrap").style.display = isHost ? "block" : "none";
      updateDeckelToggleState();
      updateLobbyVisibility();

      const myTurnNow = isMyTurn();
      if (myTurnNow && !wasMyTurn) {
        notifyMyTurn(currentName);
      }
      wasMyTurn = myTurnNow;

      const players = state.players || [];
      const playerList = players.length
        ? `<h4>Spieler</h4><ul>${players.map(name => `<li>${escapeHtml(name)}</li>`).join("")}</ul>`
        : "";
      document.getElementById("skatPlayers").innerHTML = playerList;

      const trickCards = state.currentTrick?.map(play => play.card) || [];
      renderSkatRow(
        document.getElementById("skatTrick"),
        trickCards,
        {
          selectable: false,
          onSelect: () => {},
          hideCards: false
        }
      );

      const myHand = mySeat >= 0 ? (state.hands?.[mySeat] || []) : [];
      renderSkatRow(
        document.getElementById("skatHand"),
        myHand,
        {
          selectable: isMyTurn() && !state.finished,
          onSelect: (index) => {
            if (!room || !isMyTurn() || state.finished) return;
            const card = myHand[index];
            if (!card) return;
            socket.emit("skat_play_card", { code: room.code, card });
          },
          hideCards: false
        }
      );

      const status = state.finished
        ? "Skat beendet."
        : `Stich ${state.trickNumber} ¬∑ ${playerCount} Spieler`;
      document.getElementById("skatResult").textContent = [state.message, status].filter(Boolean).join(" ¬∑ ");
    }

    function renderSchockenGame() {
      if (!state) return;
      document.getElementById("kniffelView").style.display = "none";
      document.getElementById("schockenView").style.display = "block";
      document.getElementById("schwimmenView").style.display = "none";
      document.getElementById("skatView").style.display = "none";
      document.getElementById("caboView").style.display = "none";

      const currentName = state.players[state.currentPlayer] || "-";
      document.getElementById("playerDisplay").textContent = `Am Zug: ${currentName}`;
      document.getElementById("throwCount").textContent = `Wurf: ${state.throwCount}`;
      document.getElementById("roundDisplay").textContent = `Runde: ${state.roundNumber}`;

      const colorIdx = state.currentPlayer % playerTextColors.length;
      document.getElementById("playerDisplay").style.color = playerTextColors[colorIdx];
      document.body.style.backgroundColor = playerBgColors[colorIdx];

      const myTurn = isMyTurn();
      for (let i = 0; i < 3; i++) {
        const el = document.getElementById(`die${i}`);
        const val = state.dice[i];
        el.textContent = val ? diceSymbols[val - 1] : "‚ñ°";
        el.className = "die" + (state.held[i] ? " held" : "") + (!myTurn ? " inactive" : "");
        el.onclick = () => {
          if (!myTurn) return;
          socket.emit("action_toggle", { code: room.code, index: i });
        };
      }

      const remaining = state.maxThrowsThisRound - state.throwCount;
      const allHeld = state.held.every(h => h);

      const rollBtn = document.getElementById("rollBtn");
      rollBtn.textContent = allHeld ? "Alle W√ºrfel gehalten" : `W√ºrfeln (${remaining})`;
      rollBtn.disabled = !myTurn || allHeld || remaining <= 0;

      const endBtn = document.getElementById("endTurnBtn");
      endBtn.disabled = !myTurn || state.throwCount === 0 || state.dice.includes(null) || state.convertedThisTurn;

      document.getElementById("turnHint").textContent =
        myTurn ? "Du bist am Zug!" : "Du bist gerade nicht am Zug (Zuschauer-Modus).";
      document.getElementById("backToLobbyWrap").style.display = isHost ? "block" : "none";
      updateDeckelToggleState();
      updateLobbyVisibility();

      const myTurnNow = myTurn;
      if (myTurnNow && !wasMyTurn) {
        notifyMyTurn(currentName);
      }
      wasMyTurn = myTurnNow;

      if (state.message) showGameMessage(state.message, false);

      updateHistoryTable();
    }

    function renderCaboScores() {
      const container = document.getElementById("caboScores");
      if (!container || !state) return;
      const scores = state.scores || [];
      const roundScores = state.roundScores || [];
      let html = "<table class='score-table'><thead><tr><th>Spieler</th><th>Gesamt</th><th>Runde</th></tr></thead><tbody>";
      state.players.forEach((name, index) => {
        const color = playerTextColors[index % playerTextColors.length];
        const total = Number.isFinite(scores[index]) ? scores[index] : 0;
        const roundScore = Number.isFinite(roundScores[index]) ? roundScores[index] : "-";
        html += `<tr><td style="color:${color};">${escapeHtml(name)}</td><td>${total}</td><td>${roundScore}</td></tr>`;
      });
      html += "</tbody></table>";
      container.innerHTML = html;
    }

    function renderCaboGame() {
      if (!state) return;
      document.getElementById("kniffelView").style.display = "none";
      document.getElementById("schockenView").style.display = "none";
      document.getElementById("schwimmenView").style.display = "none";
      document.getElementById("skatView").style.display = "none";
      document.getElementById("caboView").style.display = "block";
      document.getElementById("historyTable").style.display = "block";

      const currentName = state.players[state.currentPlayer] || "-";
      document.getElementById("playerDisplay").textContent = `Am Zug: ${currentName}`;
      document.getElementById("caboRound").textContent = `Runde: ${state.roundNumber || 1}`;

      const colorIdx = state.currentPlayer % playerTextColors.length;
      document.getElementById("playerDisplay").style.color = playerTextColors[colorIdx];
      document.body.style.backgroundColor = playerBgColors[colorIdx];

      const myTurn = isMyTurn();
      const endBtn = document.getElementById("caboEndTurnBtn");
      const scoreInput = document.getElementById("caboScoreInput");
      if (endBtn) endBtn.disabled = !myTurn;
      if (scoreInput) {
        const currentScore = state.roundScores?.[mySeat];
        scoreInput.disabled = !myTurn;
        scoreInput.value = Number.isFinite(currentScore) ? currentScore : 0;
      }

      document.getElementById("turnHint").textContent =
        myTurn ? "Du bist am Zug!" : "Du bist gerade nicht am Zug (Zuschauer-Modus).";
      document.getElementById("backToLobbyWrap").style.display = isHost ? "block" : "none";
      updateDeckelToggleState();
      updateLobbyVisibility();

      const myTurnNow = myTurn;
      if (myTurnNow && !wasMyTurn) {
        notifyMyTurn(currentName);
      }
      wasMyTurn = myTurnNow;

      document.getElementById("caboResult").textContent = state.message || "";
      renderCaboScores();
      updateHistoryTable();
    }

    function renderGame() {
      if (!state) return;
      if (isKniffelGame()) {
        renderKniffelGame();
      } else if (isSchwimmenGame()) {
        renderSchwimmenGame();
      } else if (isSkatGame()) {
        renderSkatGame();
      } else if (isCaboGame()) {
        renderCaboGame();
      } else {
        renderSchockenGame();
      }
    }

    // Keepalive: solange die Seite ge√∂ffnet ist (bis zu 72h)
    let pingTimer = null;
    let pingStopTimer = null;
    const KEEPALIVE_DURATION_MS = 72 * 60 * 60 * 1000;
    function startKeepalive() {
      if (pingTimer) return;
      pingTimer = setInterval(() => {
        fetch("/ping", { cache: "no-store" }).catch(() => {});
      }, 5 * 60 * 1000);
      if (!pingStopTimer) {
        pingStopTimer = setTimeout(() => {
          stopKeepalive();
        }, KEEPALIVE_DURATION_MS);
      }
    }
    function stopKeepalive() {
      if (!pingTimer) return;
      clearInterval(pingTimer);
      pingTimer = null;
      if (pingStopTimer) {
        clearTimeout(pingStopTimer);
        pingStopTimer = null;
      }
    }

    // ---- Socket events ----
    socket.on("room_joined", (payload) => {
      showLobbyError("");
      showJoinStatus("");
      joinPending = null;

      myRoomCode = payload.code;
      myToken = payload.token;
      mySeat = payload.seatIndex;
      myName = payload.name;
      isHost = payload.isHost;
      document.getElementById("playerName").value = myName;

      localStorage.setItem("schocken_code", myRoomCode);
      localStorage.setItem("schocken_token", myToken);
      localStorage.setItem("schocken_seat", String(mySeat));
      localStorage.setItem("schocken_name", myName);

      room = payload.room;
      state = payload.state || null;

      renderRoomView();

      if (state) {
        setView("game");
        startKeepalive();
        renderGame();
      } else {
        setView("lobby");
        updateLobbyVisibility();
      }
    });

    socket.on("room_update", (payloadRoom) => {
      room = payloadRoom;
      if (room && typeof room.hostSeat === "number" && myName) {
        if (room.status === "lobby") {
          const idx = room.players.findIndex(p => p.name.toLowerCase() === myName.toLowerCase());
          if (idx >= 0) {
            mySeat = idx;
            localStorage.setItem("schocken_seat", String(mySeat));
          }
        }
        if (mySeat >= 0) {
          isHost = room.hostSeat === mySeat;
        }
      }
      renderRoomView();
    });

    socket.on("lobby_list", (payload) => {
      renderLobbyList(payload.lobbies || []);
    });

    socket.on("join_pending", ({ code }) => {
      joinPending = { code };
      showJoinStatus(`Warte auf Best√§tigung durch den Host (${code}).`);
    });

    socket.on("join_denied", ({ message }) => {
      joinPending = null;
      showJoinStatus("");
      showLobbyError(message || "Beitritt abgelehnt.");
    });

    socket.on("join_requests_update", ({ requests }) => {
      renderPendingList(requests);
    });

    socket.on("join_request_notice", ({ name, code, requestId }) => {
      notifyJoinRequest(name, code, requestId);
    });

    socket.on("state_update", (payloadState) => {
      state = payloadState;
      setView("game");
      startKeepalive();
      renderGame();
    });

    socket.on("error_msg", ({ message }) => {
      const hadJoinPending = !!joinPending;
      showJoinStatus("");
      joinPending = null;
      if (message === "Room-Code nicht gefunden.") {
        socket.emit("get_lobby_list");
      }
      if (message === "Room-Code nicht gefunden." && myRoomCode && myToken) {
        localStorage.removeItem("schocken_code");
        localStorage.removeItem("schocken_token");
        localStorage.removeItem("schocken_seat");
        myRoomCode = null; myToken = null; mySeat = -1;
        room = null;
        state = null;
        isHost = false;
        showLobbyExpiryNotice("");
        document.getElementById("rejoinBox").style.display = "none";
        setView("lobby");
        updateDeckelToggleState();
        updateLobbyVisibility();
        showLobbyError("");
        return;
      }
      if (document.getElementById("lobby").style.display !== "none") {
        if (message === "Room-Code nicht gefunden." && hadJoinPending) {
          showLobbyError("Lobby existiert nicht mehr.");
        } else {
          showLobbyError(message);
        }
      }
      else showGameMessage(message, true);
    });

    socket.on("lobby_returned", ({ message } = {}) => {
      setView("lobby");
      document.body.style.backgroundColor = "";
      wasMyTurn = false;
      showLobbyError(isHost ? "" : (message || ""));
      updateLobbyVisibility();
    });

    socket.on("lobby_expiring", ({ code, secondsLeft }) => {
      if (!room || room.code !== code || room.status !== "lobby") return;
      const seconds = Number.isFinite(secondsLeft) ? secondsLeft : 30;
      showLobbyExpiryNotice(`Diese Lobby wird in ${seconds} Sekunden gel√∂scht. Klick auf ‚ÄûLobby behalten‚Äú, um sie zu behalten.`);
    });

    socket.on("lobby_keep_confirmed", ({ code, message }) => {
      if (!room || room.code !== code) return;
      showLobbyExpiryNotice(message || "Lobby bleibt bestehen.");
      setTimeout(() => {
        showLobbyExpiryNotice("");
      }, 2000);
    });

    socket.on("lobby_deleted", ({ code, message } = {}) => {
      if (!room || room.code !== code) return;
      room = null;
      state = null;
      myRoomCode = null;
      myToken = null;
      mySeat = -1;
      isHost = false;
      localStorage.removeItem("schocken_code");
      localStorage.removeItem("schocken_token");
      localStorage.removeItem("schocken_seat");
      setView("lobby");
      showLobbyError(message || "Lobby wurde gel√∂scht.");
      updateDeckelToggleState();
      updateLobbyVisibility();
      socket.emit("get_lobby_list");
    });

    socket.on("room_left", ({ message } = {}) => {
      room = null;
      state = null;
      myRoomCode = null;
      myToken = null;
      mySeat = -1;
      isHost = false;
      localStorage.removeItem("schocken_code");
      localStorage.removeItem("schocken_token");
      localStorage.removeItem("schocken_seat");
      setView("lobby");
      showLobbyError(message || "");
      updateDeckelToggleState();
      updateLobbyVisibility();
      socket.emit("get_lobby_list");
    });

    // ---- Buttons ----
    document.getElementById("btnEnter").onclick = () => {
      const name = getPlayerName();
      const code = document.getElementById("roomCode").value.trim().toUpperCase();
      const useDeckel = document.getElementById("deckelToggle").checked;
      const gameType = getSelectedGameType();
      if (!name) return showLobbyError("Bitte Name eingeben.");
      if (!canEnterRoom(code)) return;
      storePlayerName(name);
      showLobbyError("");
      if (code) {
        showJoinStatus(`Beitritt f√ºr ${code} angefragt‚Ä¶`);
        joinPending = { code };
      } else {
        showJoinStatus("Erstelle neue Lobby‚Ä¶");
      }
      socket.emit("enter_room", { name, requestedCode: code, useDeckel, gameType });
    };

    document.getElementById("btnStartGame").onclick = () => {
      if (!room || !myToken) return;
      socket.emit("start_game", { code: room.code, token: myToken });
    };

    document.getElementById("btnLeaveLobby").onclick = () => {
      if (!room || !myToken) return;
      if (room.status !== "lobby") return;
      const confirmText = isHost
        ? "Lobby verlassen? Du gibst den Host-Status ab."
        : "Lobby verlassen?";
      if (!window.confirm(confirmText)) return;
      socket.emit("leave_room", { code: room.code, token: myToken });
    };

    document.getElementById("btnKeepLobby").onclick = () => {
      if (!room || !myToken || room.status !== "lobby") return;
      socket.emit("keep_lobby", { code: room.code, token: myToken });
    };

    document.getElementById("rollBtn").onclick = () => {
      if (!room) return;
      if (isKniffelGame()) return;
      socket.emit("action_roll", { code: room.code });
    };

    document.getElementById("endTurnBtn").onclick = () => {
      if (!room) return;
      if (isKniffelGame()) return;
      socket.emit("action_end_turn", { code: room.code });
    };

    document.getElementById("kniffelRollBtn").onclick = () => {
      if (!room) return;
      if (!isKniffelGame()) return;
      socket.emit("action_roll", { code: room.code });
    };

    document.getElementById("kniffelEndTurnBtn").onclick = () => {
      if (!room) return;
      if (!isKniffelGame()) return;
      const category = document.getElementById("kniffelCategorySelect").value;
      socket.emit("action_end_turn", { code: room.code, category });
    };

    document.getElementById("kniffelCategorySelect").onchange = () => {
      updateKniffelEndButton();
    };

    document.getElementById("schwimmenSwapBtn").onclick = () => {
      if (!room || !isSchwimmenGame()) return;
      if (selectedHandIndex === null || selectedTableIndex === null) return;
      socket.emit("schwimmen_swap", {
        code: room.code,
        handIndex: selectedHandIndex,
        tableIndex: selectedTableIndex
      });
    };

    document.getElementById("schwimmenSwapAllBtn").onclick = () => {
      if (!room || !isSchwimmenGame()) return;
      socket.emit("schwimmen_swap_all", { code: room.code });
    };

    document.getElementById("schwimmenPassBtn").onclick = () => {
      if (!room || !isSchwimmenGame()) return;
      socket.emit("schwimmen_pass", { code: room.code });
    };

    document.getElementById("schwimmenKnockBtn").onclick = () => {
      if (!room || !isSchwimmenGame()) return;
      socket.emit("schwimmen_knock", { code: room.code });
    };

    document.getElementById("schwimmenNextRoundBtn").onclick = () => {
      if (!room || !isSchwimmenGame()) return;
      selectedHandIndex = null;
      selectedTableIndex = null;
      socket.emit("schwimmen_start_round", { code: room.code });
    };

    document.getElementById("caboEndTurnBtn").onclick = () => {
      if (!room || !isCaboGame()) return;
      const scoreInput = document.getElementById("caboScoreInput");
      const scoreValue = scoreInput ? Number(scoreInput.value || 0) : 0;
      socket.emit("cabo_end_turn", { code: room.code, score: scoreValue });
    };

    document.getElementById("btnBackToLobby").onclick = () => {
      if (isHost && room && myToken) {
        const ok = window.confirm("Zur√ºck zur Lobby? Das beendet das Spiel und l√∂scht den Fortschritt.");
        if (ok) {
          socket.emit("return_lobby", { code: room.code, token: myToken });
        }
        return;
      }
      showLobbyError("Nur der Host kann alle zur√ºck in die Lobby schicken.");
    };

    document.getElementById("btnRejoin").onclick = () => {
      if (!myRoomCode || !myToken) return;
      socket.emit("rejoin_room", { code: myRoomCode, token: myToken });
    };

    document.getElementById("btnForget").onclick = () => {
      localStorage.removeItem("schocken_code");
      localStorage.removeItem("schocken_token");
      localStorage.removeItem("schocken_seat");
      myRoomCode = null; myToken = null; mySeat = -1;
      room = null;
      state = null;
      isHost = false;
      joinPending = null;
      showLobbyExpiryNotice("");
      document.getElementById("rejoinBox").style.display = "none";
      showLobbyError("Vergessen. Du kannst neu erstellen oder beitreten.");
      updateDeckelToggleState();
      updateLobbyVisibility();
      socket.emit("get_lobby_list");
    };

    document.getElementById("btnNewCode").onclick = () => {
      setSuggestedCode();
    };

    document.getElementById("playerName").addEventListener("input", (event) => {
      storePlayerName(event.target.value.trim());
    });

    document.getElementById("deckelToggle").onchange = (event) => {
      if (!room || !myToken) return;
      if (!isHost || room.status !== "lobby") {
        event.target.checked = !!room?.settings?.useDeckel;
        return;
      }
      socket.emit("update_room_settings", {
        code: room.code,
        token: myToken,
        useDeckel: event.target.checked,
        gameType: room.settings?.gameType || "schocken"
      });
    };

    document.getElementById("gameTypeSelect").onchange = (event) => {
      updateDeckelToggleState();
      updateHeader("lobby");
      updateStartButtonState();
      if (!room || !myToken) return;
      if (!isHost || room.status !== "lobby") {
        event.target.value = room?.settings?.gameType || "schocken";
        return;
      }
      socket.emit("update_room_settings", {
        code: room.code,
        token: myToken,
        useDeckel: room.settings?.useDeckel,
        gameType: event.target.value
      });
    };

    window.onload = () => {
      setSuggestedCode();
      document.getElementById("gameTypeSelect").value = "schocken";
      updateHeader("lobby");
      if (myName) {
        document.getElementById("playerName").value = myName;
      }
      if (myRoomCode && myToken) {
        document.getElementById("rejoinBox").style.display = "block";
      }
      showJoinStatus("");
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("/sw.js").catch(() => {});
      }
      startKeepalive();
    };

    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.addEventListener("message", event => {
        const data = event.data || {};
        if (data.type !== "join_request_action") return;
        if (!room || !myToken || !isHost || room.status !== "lobby") return;
        if (data.code !== room.code) return;
        const accept = data.action === "approve";
        if (!data.requestId) return;
        socket.emit("approve_join", {
          code: data.code,
          token: myToken,
          requestId: data.requestId,
          accept
        });
      });
    }

    document.getElementById("btnReload").onclick = () => {
      window.location.reload();
    };

    socket.on("connect", () => {
      if (myRoomCode && myToken) {
        socket.emit("rejoin_room", { code: myRoomCode, token: myToken });
      }
      socket.emit("get_lobby_list");
    });

    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "visible") {
        if (myRoomCode && myToken) {
          socket.emit("rejoin_room", { code: myRoomCode, token: myToken });
        }
        socket.emit("get_lobby_list");
      }
    });

    function updateDeckelToggleState() {
      const toggle = document.getElementById("deckelToggle");
      if (!toggle) return;
      const selectedType = room?.settings?.gameType
        || document.getElementById("gameTypeSelect")?.value
        || "schocken";
      const isSchocken = selectedType === "schocken";
      if (room && room.status === "lobby") {
        toggle.checked = !!room.settings?.useDeckel && isSchocken;
      }
      toggle.disabled = !!room
        ? (!isHost || room.status !== "lobby" || !isSchocken)
        : !isSchocken;
      toggle.parentElement.style.display = isSchocken ? "flex" : "none";
    }

    function getGameStartStatus() {
      const selectedType = room?.settings?.gameType
        || document.getElementById("gameTypeSelect")?.value
        || "schocken";
      const requirement = getGameTypeRequirement(selectedType);
      const playerCount = room?.players?.length || 0;
      if (requirement.exact && playerCount !== requirement.exact) {
        return {
          ok: false,
          reason: `${getGameTypeLabel(selectedType)} ben√∂tigt genau ${requirement.exact} Spieler (aktuell ${playerCount}).`
        };
      }
      if (requirement.min && playerCount < requirement.min) {
        return {
          ok: false,
          reason: `${getGameTypeLabel(selectedType)} ben√∂tigt mindestens ${requirement.min} Spieler (aktuell ${playerCount}).`
        };
      }
      if (requirement.max && playerCount > requirement.max) {
        return {
          ok: false,
          reason: `${getGameTypeLabel(selectedType)} erlaubt h√∂chstens ${requirement.max} Spieler (aktuell ${playerCount}).`
        };
      }
      return { ok: true, reason: "" };
    }

    function updateStartButtonState() {
      const startButton = document.getElementById("btnStartGame");
      const hint = document.getElementById("hostStartHint");
      if (!startButton || !hint) return;
      if (!room || room.status !== "lobby") {
        startButton.disabled = true;
        hint.textContent = isHost ? "Nur du kannst das Spiel starten." : "Nur der Host kann das Spiel starten.";
        return;
      }
      const status = getGameStartStatus();
      startButton.disabled = !isHost || !status.ok;
      if (!status.ok) {
        hint.textContent = status.reason;
      } else {
        hint.textContent = isHost ? "Nur du kannst das Spiel starten." : "Nur der Host kann das Spiel starten.";
      }
    }

    function updateGameTypeSelectState() {
      const select = document.getElementById("gameTypeSelect");
      if (!select) return;
      const current = room?.settings?.gameType || "schocken";
      select.value = current;
      select.disabled = !!room && (!isHost || room.status !== "lobby");
    }
    function updateGameTypeState() {
      const select = document.getElementById("gameTypeSelect");
      if (!select) return;
      if (room && room.status === "lobby") {
        select.value = room.settings?.gameType || "schocken";
      }
      select.disabled = !!room && (!isHost || room.status !== "lobby");
    }

    function updateLobbyVisibility() {
      const inLobby = !!room && room.status === "lobby";
      const list = document.getElementById("activeLobbies");
      const roomView = document.getElementById("roomView");
      if (roomView) {
        roomView.style.display = inLobby ? "block" : "none";
      }
      if (!inLobby) {
        showLobbyExpiryNotice("");
      }
      if (list) {
        list.style.display = inLobby ? "none" : "block";
      }
      if (!inLobby && list && list.innerHTML.trim() === "") {
        list.innerHTML = "<div class='small muted'>Aktive Lobbys werden geladen‚Ä¶</div>";
      }
    }
  </script>
</body>
</html>
